# This workflow will install Python dependencies, run pytests and run notebooks
# then it will in python 3.9 (ubuntu-latest) create a badge with the coverage
# and add it to the PR. This badge will be updated if the PR is updated.

name: Tests
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  pytest:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest] #, macos-latest]
        python-version: ["3.9"] # , "3.8"]

    # This allows a subsequently queued workflow run to interrupt previous runs
    concurrency:
      group: "${{ github.workflow }}-${{ matrix.python-version}}-${{ matrix.os }} @ ${{ github.ref }}"
      cancel-in-progress: true

    steps:
      - uses: actions/checkout@v3

      - name: Cache venv
        uses: actions/cache@v3.2.6
        id: cache_venv
        with:
          path: |
            .venv
          key: ${{ runner.os }}-venv-${{ matrix.python-version }}-${{ hashFiles('**/pyproject.toml') }}

      - name: Set up Python
        uses: actions/setup-python@v4
        id: setup_python
        if: steps.cache_venv.outputs.cache-hit != 'true'
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        shell: bash
        run: |
          python -m venv .venv
          source .venv/bin/activate
          python -m pip install --upgrade pip
          pip install -e .[tests]

      - name: Run and write pytest
        id: run_pytest
        shell: bash
        continue-on-error: true
        run: |
          source .venv/bin/activate

          if pytest --durations=0 -n 2 -x --junitxml=pytest.xml --cov-report=term-missing --cov=src/ tests/; then
            echo "Tests passed"
            echo "tests_failed=0" >> $GITHUB_OUTPUT
          else
            echo "Tests failed"
            echo "tests_failed=1" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Parse test results and post PR comment
        uses: actions/github-script@v4
        if: ${{ steps.run_pytest.outputs.tests_failed == 1 }}
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        with:
          script: |
            const parser = require('junitparser');
            const fs = require('fs');
            const results = parser.parse(fs.readFileSync('junit/test-results.xml'));
            const summary = results.summary;
            let failedTests = '';
            for (const testSuite of results.testSuites) {
              for (const testCase of testSuite.testCases) {
                if (testCase.failure !== null || testCase.error !== null) {
                  failedTests += `- ${testSuite.name}.${testCase.name}\n`;
                }
              }
            }
            let commentBody = `Test Summary: ${summary.tests} tests run, ${summary.failures} failures, ${summary.errors} errors\n\n`;
            if (failedTests !== '') {
              commentBody += 'The following tests failed or had errors:\n';
              commentBody += failedTests;
            } else {
              commentBody += 'All tests passed!';
            }
            github.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });

      # if it is run on ubuntu-latest, python 3.9, then create the badge
      - name: Pytest coverage comment
        id: coverage-comment
        uses: MishaKav/pytest-coverage-comment@main
        if: ${{ github.actor != 'dependabot[bot]' }}
        with:
          create-new-comment: false
          report-only-changed-files: false
          pytest-coverage-path: pytest-coverage.txt
          junitxml-path: ./pytest.xml

      - name: Check the output coverage
        if: ${{ matrix.os == 'ubuntu-latest' && matrix.python-version == '3.9' }}
        shell: bash
        run: |
          echo "Coverage Report - ${{ steps.coverage-comment.outputs.coverage }}"
          echo "Coverage Color - ${{ steps.coverage-comment.outputs.color }}"
