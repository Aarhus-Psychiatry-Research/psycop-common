diff a/tasks.py b/tasks.py	(rejected hunks)
@@ -1,4 +1,23 @@
+"""
+This project uses Invoke (pyinvoke.org) for task management.
+Install it via:
+
+```
+pip install invoke
+```
+
+And then run:
+
+```
+inv --list
+```
+"""
+
+
+import re
+from dataclasses import dataclass
 from pathlib import Path
+from typing import Optional
 
 from invoke import Context, Result, task
 
@@ -7,93 +26,63 @@ def echo_header(msg: str):
     print(f"\n--- {msg} ---")
 
 
-@task
-def setup(c: Context, python_version: str = "3.9"):
-    git_init(c)
-    setup_venv(c, python_version=python_version)
-    install(c)
+@dataclass
+class Emo:
+    DO = "ðŸ¤–"
+    GOOD = "âœ…"
+    FAIL = "ðŸš¨"
+    WARN = "ðŸš§"
+    SYNC = "ðŸš‚"
+    PY = "ðŸ"
+    CLEAN = "ðŸ§¹"
+    TEST = "ðŸ§ª"
+    COMMUNICATE = "ðŸ“£"
 
 
 def git_init(c: Context):
     # If no .git directory exits
     if not Path(".git").exists():
-        echo_header("ðŸ”¨ Initializing Git repository")
+        echo_header(f"{Emo.DO} Initializing Git repository")
         c.run("git init")
         c.run("git add .")
         c.run("git commit -m 'Initial commit'")
-        print("âœ… Git repository initialized")
+        print(f"{Emo.GOOD} Git repository initialized")
     else:
-        print("âœ… Git repository already initialized")
+        print(f"{Emo.GOOD} Git repository already initialized")
 
 
 def setup_venv(
     c: Context,
     python_version: str,
-):
+) -> str:
     venv_name = f'.venv{python_version.replace(".", "")}'
 
     if not Path(venv_name).exists():
-        echo_header("ðŸ”¨ Creating virtual environment")
+        echo_header(
+            f"{Emo.DO} Creating virtual environment for {Emo.PY}{python_version}",
+        )
         c.run(f"python{python_version} -m venv {venv_name}")
-        print("âœ… Virtual environment created")
+        print(f"{Emo.GOOD} Virtual environment created")
     else:
-        print("âœ… Virtual environment already exists")
+        print(f"{Emo.GOOD} Virtual environment already exists")
 
     c.run(f"source {venv_name}/bin/activate")
 
+    return venv_name
 
-@task
-def install(c: Context):
-    echo_header("ðŸ”¨ Installing project")
-    c.run("pip install -e '.[dev,tests]'")
-
-
-@task
-def update(c: Context):
-    echo_header("ðŸ”¨ Updating project")
-    c.run("pip install --upgrade -e '.[dev,tests]'")
-
-
-@task
-def test(c: Context):
-    echo_header("ðŸ§ª Running tests")
-    test_result: Result = c.run(
-        "pytest -n auto -rfE --failed-first -p no:typeguard -p no:cov --disable-warnings -q",
-        warn=True,
-        pty=True,
-    )
 
-    # If "failed" in the pytest results
-    if "failed" in test_result.stdout:
-        print("\n\n\n")
-        echo_header("Failed tests")
-
-        # Get lines with "FAILED" in them from the .pytest_results file
-        failed_tests = [
-            line
-            for line in Path("tests/.pytest_results").read_text().splitlines()
-            if line.startswith("FAILED")
-        ]
-
-        for line in failed_tests:
-            # Remove from start of line until /test_
-            line_sans_prefix = line[line.find("test_") :]
-
-            # Keep only that after ::
-            line_sans_suffix = line_sans_prefix[line_sans_prefix.find("::") + 2 :]
-            print(f"FAILED ðŸš¨ #{line_sans_suffix}     ")
-
-        exit(0)
-
-
-def add_commit(c: Context):
+def _add_commit(c: Context, msg: Optional[str] = None):
     print("ðŸ”¨ Adding and committing changes")
     c.run("git add .")
-    commit_msg = input("Commit message: ")
-    c.run(f'git commit -m "{commit_msg}"')
+
+    if msg is None:
+        msg = input("Commit message: ")
+
+    c.run(f'git commit -m "{msg}"', pty=True, hide=True)
+    print("\nðŸ¤– Changes added and committed\n")
 
 
-def add_and_commit(c: Context):
+def is_uncommitted_changes(c: Context) -> bool:
     git_status_result: Result = c.run(
         "git status --porcelain",
         pty=True,
@@ -101,32 +90,41 @@ def add_and_commit(c: Context):
     )
 
     uncommitted_changes = git_status_result.stdout != ""
-    uncommitted_changes_descr = git_status_result.stdout
+    return uncommitted_changes
+
+
+def add_and_commit(c: Context, msg: Optional[str] = None):
+    """Add and commit all changes."""
+    if is_uncommitted_changes(c):
+        uncommitted_changes_descr = c.run(
+            "git status --porcelain",
+            pty=True,
+            hide=True,
+        ).stdout
 
-    if uncommitted_changes:
         echo_header(
-            "ðŸš§ Uncommitted changes detected",
+            f"{Emo.WARN} Uncommitted changes detected",
         )
 
-        input("Press enter to add and commit the changes...")
-
         for line in uncommitted_changes_descr.splitlines():
             print(f"    {line.strip()}")
         print("\n")
-        add_commit(c)
+        _add_commit(c, msg=msg)
 
 
-@task
-def pr(c: Context):
-    add_and_commit(c)
-    lint(c)
-    test(c)
-    sync_with_git_remote(c)
-    sync_pr(c)
+def branch_exists_on_remote(c: Context) -> bool:
+    branch_name = Path(".git/HEAD").read_text().split("/")[-1].strip()
+
+    branch_exists_result: Result = c.run(
+        f"git ls-remote --heads origin {branch_name}",
+        hide=True,
+    )
+
+    return branch_name in branch_exists_result.stdout
 
 
-def sync_with_git_remote(c: Context):
-    echo_header("ðŸš‚ Syncing branch with remote")
+def update_branch(c: Context):
+    echo_header(f"{Emo.SYNC} Syncing branch with remote")
 
     if not branch_exists_on_remote(c):
         c.run("git push --set-upstream origin HEAD")
@@ -137,8 +135,15 @@ def sync_with_git_remote(c: Context):
         c.run("git push")
 
 
-def sync_pr(c: Context):
-    echo_header("ðŸ’¬ Syncing PR")
+def create_pr(c: Context):
+    c.run(
+        "gh pr create --web",
+        pty=True,
+    )
+
+
+def update_pr(c: Context):
+    echo_header(f"{Emo.COMMUNICATE} Syncing PR")
     # Get current branch name
     branch_name = Path(".git/HEAD").read_text().split("/")[-1].strip()
     pr_result: Result = c.run(
@@ -179,11 +262,10 @@ def lint(c: Context):
     mypy(c)
 
 
-def pre_commit(c: Context):
-    echo_header("ðŸ§¹ Running pre-commit checks")
-    c.run("pre-commit run --all-files", pty=True)
-
-
-def mypy(c: Context):
-    echo_header("ðŸ§¹ Running mypy")
-    c.run("mypy .", pty=True)
+@task
+def pr(c: Context):
+    add_and_commit(c)
+    lint(c)
+    test(c)
+    update_branch(c)
+    update_pr(c)
